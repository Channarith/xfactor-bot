"""
Base strategy class that all trading strategies inherit from.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional, Any

import pandas as pd
from loguru import logger


class SignalType(str, Enum):
    """Trading signal types."""
    STRONG_BUY = "strong_buy"
    BUY = "buy"
    HOLD = "hold"
    SELL = "sell"
    STRONG_SELL = "strong_sell"
    
    @property
    def is_bullish(self) -> bool:
        """Check if signal is bullish."""
        return self in (SignalType.STRONG_BUY, SignalType.BUY)
    
    @property
    def is_bearish(self) -> bool:
        """Check if signal is bearish."""
        return self in (SignalType.STRONG_SELL, SignalType.SELL)
    
    @property
    def multiplier(self) -> float:
        """Get position size multiplier based on signal strength."""
        multipliers = {
            SignalType.STRONG_BUY: 1.0,
            SignalType.BUY: 0.5,
            SignalType.HOLD: 0.0,
            SignalType.SELL: -0.5,
            SignalType.STRONG_SELL: -1.0,
        }
        return multipliers.get(self, 0.0)


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    symbol: str
    signal_type: SignalType
    strategy: str
    strength: float  # 0.0 to 1.0
    confidence: float  # 0.0 to 1.0
    timestamp: datetime = field(default_factory=datetime.utcnow)
    
    # Optional metadata
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    expiry: Optional[datetime] = None
    metadata: dict = field(default_factory=dict)
    
    @property
    def is_actionable(self) -> bool:
        """Check if signal is actionable (not a hold)."""
        return self.signal_type != SignalType.HOLD
    
    @property
    def composite_score(self) -> float:
        """Calculate composite score (strength * confidence * direction)."""
        return self.strength * self.confidence * self.signal_type.multiplier
    
    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "symbol": self.symbol,
            "signal_type": self.signal_type.value,
            "strategy": self.strategy,
            "strength": self.strength,
            "confidence": self.confidence,
            "timestamp": self.timestamp.isoformat(),
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "metadata": self.metadata,
        }


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    All strategies must implement:
    - analyze(): Generate signals for a given symbol
    - get_parameters(): Return current strategy parameters
    
    Strategies can optionally implement:
    - on_bar(): Called on each new bar
    - on_signal(): Called when a signal is generated
    - on_fill(): Called when an order is filled
    """
    
    def __init__(self, name: str, weight: float = 1.0):
        """
        Initialize base strategy.
        
        Args:
            name: Strategy name
            weight: Strategy weight for signal aggregation (0-1)
        """
        self.name = name
        self.weight = weight
        self._enabled = True
        self._parameters: dict[str, Any] = {}
        self._last_signals: dict[str, Signal] = {}
    
    @property
    def is_enabled(self) -> bool:
        """Check if strategy is enabled."""
        return self._enabled
    
    def enable(self) -> None:
        """Enable the strategy."""
        self._enabled = True
        logger.info(f"Strategy {self.name} enabled")
    
    def disable(self) -> None:
        """Disable the strategy."""
        self._enabled = False
        logger.info(f"Strategy {self.name} disabled")
    
    def set_weight(self, weight: float) -> None:
        """Set strategy weight."""
        self.weight = max(0.0, min(1.0, weight))
        logger.info(f"Strategy {self.name} weight set to {self.weight}")
    
    def update_parameter(self, key: str, value: Any) -> None:
        """Update a strategy parameter."""
        if key in self._parameters:
            old_value = self._parameters[key]
            self._parameters[key] = value
            logger.info(f"Strategy {self.name}: {key} changed from {old_value} to {value}")
    
    @abstractmethod
    async def analyze(
        self,
        symbol: str,
        data: pd.DataFrame,
        **kwargs,
    ) -> Optional[Signal]:
        """
        Analyze a symbol and generate a trading signal.
        
        Args:
            symbol: Stock symbol
            data: DataFrame with OHLCV data
            **kwargs: Additional data (news, sentiment, etc.)
            
        Returns:
            Signal or None if no signal generated
        """
        pass
    
    @abstractmethod
    def get_parameters(self) -> dict[str, Any]:
        """
        Get current strategy parameters.
        
        Returns:
            Dictionary of parameter names and values
        """
        pass
    
    async def analyze_multiple(
        self,
        symbols: list[str],
        data: dict[str, pd.DataFrame],
        **kwargs,
    ) -> list[Signal]:
        """
        Analyze multiple symbols.
        
        Args:
            symbols: List of symbols
            data: Dictionary of symbol -> DataFrame
            
        Returns:
            List of signals
        """
        signals = []
        for symbol in symbols:
            if symbol in data:
                signal = await self.analyze(symbol, data[symbol], **kwargs)
                if signal and signal.is_actionable:
                    signals.append(signal)
                    self._last_signals[symbol] = signal
        return signals
    
    def get_last_signal(self, symbol: str) -> Optional[Signal]:
        """Get the last signal for a symbol."""
        return self._last_signals.get(symbol)
    
    def on_bar(self, symbol: str, bar: dict) -> None:
        """
        Called on each new bar. Override in subclass if needed.
        
        Args:
            symbol: Stock symbol
            bar: Bar data (open, high, low, close, volume)
        """
        pass
    
    def on_signal(self, signal: Signal) -> None:
        """
        Called when a signal is generated. Override in subclass if needed.
        
        Args:
            signal: Generated signal
        """
        logger.info(
            f"[{self.name}] Signal: {signal.symbol} {signal.signal_type.value} "
            f"(strength={signal.strength:.2f}, confidence={signal.confidence:.2f})"
        )
    
    def on_fill(self, symbol: str, side: str, quantity: float, price: float) -> None:
        """
        Called when an order is filled. Override in subclass if needed.
        
        Args:
            symbol: Stock symbol
            side: Order side (BUY/SELL)
            quantity: Filled quantity
            price: Fill price
        """
        pass
    
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name={self.name}, weight={self.weight}, enabled={self._enabled})"

